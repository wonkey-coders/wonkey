'Part 14 - Make the player able to absorb the rocks with an effect
'1) Add a Chipmunk sensor to the player
'2) Set up a collision handler for when the sensor hits a rock
'3) Add an effect for when a rock is hit and use a lambda to position it as the player moves about


'Give our game a namespace, we probably won't need it but it's good practice
Namespace spacecraft

'Import the modules that we will need:
'std is a standard set of useful functionality that you will need 99% of the time
#Import "<std>"
'Mojo handles all of our graphics drawing
#Import "<mojo>"
'chipmunk is a wrapper for the popular 2d physics library that can manage all of our collisions, physics
'and also off screen culling so that we're not rendering more than we need to
#Import "<chipmunk>"
'Import TimelineFX
#Import "<timelinefx>"
'Our own individual files for including
#Import "gameobject"
#Import "player"
#Import "tiles"
#Import "parallax"
#Import "weapons"
#Import "rocks"
#Import "chipmunkdebugger"

'Import everything that's in our assets folder ready for using
#Import "assets/"

'We also need to tell Wonkey which modules we're "Using"
Using std..
Using mojo..
Using chipmunk..
Using timelinefx..

'Create some Constants for our collision groups. Collision groups are used to determined which objects should be
'allowed to collide with each other in the chipmunk space. Groups are assigned a bit in a 32bit bitmask, so we
'can use "Shl" command to shift our bits to the left to create each group. For example group 1 is:
'00000000000000000000000000000001
'Then if we shift that bit to the left we make group 2:
'00000000000000000000000000000010
'And so on. Also note that an unsigned int (UInt) is used as we don't need to worry about negative numbers
Const MapTiles:=UInt(1)               ' = 00000000000000000000000000000001
Const Players:=UInt(1 Shl 1)          ' = 00000000000000000000000000000010
Const Rocks:=UInt(1 Shl 2)            ' = 00000000000000000000000000000100
Const Utilities:=UInt(1 Shl 3)        ' = 00000000000000000000000000001000
Const PlayerSensors:=UInt(1 Shl 4)    ' = 00000000000000000000000000010000

'Some collision types to organise how different object types collide with each other
Const PlayerCT:Int = 1
Const RocksCT:Int = 2

'Create a global variable that we can use for our virtual resolution. Virtual resolution allows us to
'make the screen space of the game the same no matter what the actual resolution is.
Global VirtualResolution:Vec2f = New Vec2f(800, 600)

'Our main window class which extends the mojo Window class
Class SpaceCraft Extends Window
	'A field to store our player
	Field Player:Player

	'Because we will have a world that you can move about in, we need some way of storing where the camera is
	'in that world so that the game objects can be drawn in the right places by offsetting their coordinates
	'by this vector
	Field Origin:Vec2f

	'cpSpace is from chipmunk and it's used to manage all of our objects for us. Every GameObject that we create
	'will be added to the space
	Field Space:cpSpace

	'It's useful to store the canvas where the game is drawn to so we can access it easily elsewhere
	Field CurrentCanvas:Canvas

	'There's a rule with adding and removing things to the chipmunk space: You can't do it while you're looping
	'through objects in the space. You're doing this any time you're checking for collisions or querying objects
	'in the space. To manage this we can use 2 stacks to temporarily store objects that we want to remove or add
	'to the space, and then add them after we've finished sorting out all the collisions and rendering etc.
	Field AddToSpace:Stack<GameObject>
	Field RemoveFromSpace:Stack<GameObject>

	'This is a reference to Self so that we can use it as a pointer to pass into chipmunk queries. See the chipmunk
	'queries in action in Update and RenderSpace methods
	Field Me:SpaceCraft

	'Test tile set just to make sure it all loads ok
	Field TestTileSet:TileSet

	'Tilemap to manage the game terrain tiles
	Field Map:TileMap

	'A vec to store the center point of the screen.
	Field Center:Vec2f

	'Field to store the parallax background
	Field Background:Parallax

	'Create fields for all of the particle objects. We'll start with a Particle Manager for
	'keeping track of and drawing all of the weapon particle effects
	Field WeaponPM:tlParticleManager
	'And a field to store the effects library that stores all of the effects
	Field Effects:tlEffectsLibrary

	'Teh screen scale is calculated by taking the virtual screen size and dividing it by the
	Field ScreenScale:Vec2f

	'This is a work around for memory access errors caused by the garbage collector deleting chipmunk objects from memory.
	'This happens because the garbage collector doesn't know about chipmunk objects so it thinks nothing is referencing
	'and therefore just deletes them. We get round this by adding objects to this list - the GC then sees that they're being
	'referenced and leaves them alone.
	Field ObjectList:List<GameObject> = New List<GameObject>

	'Collision handlers
	Field RockCollection:cpCollisionHandler

	Method New( title:String="Spacecraft",width:Int=800,height:Int=600,flags:WindowFlags=WindowFlags.Resizable )
		'Call the "New" method in the parent class that we're extending
		Super.New( title,width,height,flags )

		'Create our stacks for adding and removing to/from the Space
		AddToSpace = New Stack<GameObject>
		RemoveFromSpace = New Stack<GameObject>

		'Set the Me field
		Me = Self

		'Set the origin to the center of the screen
		Origin = New Vec2f(-Width / 2, -Height / 2)

		'Set the center vec
		Center = New Vec2f(Width / 2, Height / 2)

		InitGame()
	End

	'method where we setup all our variables with the initial values
	Method InitGame()
		'Create our chipmunk space
		Space = cpSpaceNew()

		'Set the graviity of the space. We want it pointing downwards and use a force of 500 which produces physics
		'that work well but you can experiment with this number
		cpSpaceSetGravity(Space, cpv(0, 500))

		'Load in the effects library
		Effects = LoadEffects("asset::effects")

		'Load in some tiles just to test with
		TestTileSet = New TileSet
		TestTileSet.Load("asset::tiles/solidblock.json")

		'Create a TileMap to contain the game map
		Map = New TileMap
		'Reference the game object in the TileMap, we'll need it to access the chipmunk space primarily
		Map.Game = Self
		Map.AssignTileSet(0, TestTileSet)
		Map.Layers[0].RockImage = Image.Load("asset::rocks/rock.png")

		'Create the parallax background
		Background = New Parallax(Image.Load("asset::backgrounds/rockbackground.png"), Width, Height)

		'Create a particle manager for the weapon effects
		WeaponPM = New tlParticleManager

		'Let the particle manager know the screen size so it can skip drawing off-screen particles
		WeaponPM.SetScreenSize(Width, Height)

		'And set the update frequency of TimelineFX to 60 FPS
		SetUpdateFrequency(60)

		'Create a new player and load in an image for it. Set it to some initial coordinates and scale it down a bit.
		'See the Player and GameObject classes for how the physics are set up and the object is added to the Space
		Player = New Player(Self, 0, 0)
		Player.Image = Image.Load("asset::Player/player.png")
		Player.Scale = New Vec2f(0.35, 0.35)

		InitCollisionHandlers()
	End

	Method InitCollisionHandlers()
		'We can initialise all of the collision handlers in this method
		'We use the chipmuck function cpSpaceAddCollisionHandler to create a collision handler for when a rock type
		'hits a player type
		RockCollection = cpSpaceAddCollisionHandler(Space, RocksCT, PlayerCT)

		'There're various callbacks we can use but the one we're interested in is beginFunc - this is called the moment the
		'collision occurrs
		RockCollection.beginFunc = RockCollectionHandler
	End

	'This is the callback function for when a rock touches the player
	Function RockCollectionHandler:cpBool( arbiter:cpArbiter, space:cpSpace, data:cpDataPointer )

		Local rockshape:cpShape
		Local playershape:cpShape

		'Use cpArbiterGetShapes to get pointers to the rockshape and player shape involved in this collision
		cpArbiterGetShapes(arbiter, Varptr rockshape, Varptr playershape)

		'Cast the shape pointers to objects so that we can access what we need to
		Local rock:=Cast<RockObject Ptr>(rockshape.UserData)[0]
		Local player:=Cast<Player Ptr>(playershape.UserData)[0]

		'Let the rock know that it's been collected and can now be removed from the map
		rock.Collected = True

		'Grab a copy of the absorb effect from the effects library
		Local e:tlEffect = CopyEffect(player.Game.Effects.GetEffect("Absorb"), player.Game.WeaponPM)
		'Set the effect position to the player
		e.SetPosition(player.XY.x, player.XY.y)
		'Adjust the scale of the effect
		e.SetZ(0.3)
		'Every effect has an OnUpdate function pointer that we can use to do something specific to the effect each update
		'This is where Lambdas can be very useful. A Lambda is an "anonymous function" that can be called everytime the
		'effect updates, and a useful advantage is that it can take a local variable from here to use in the lambda, in
		'this case the player and the effect itself. So we use those 2 variables to set the position of the effect to the
		'player position each update
		e.OnUpdate = Lambda()
			e.SetPosition(player.XY.x, player.XY.y)
		End
		'Add the effect to the particle manager
		player.Game.WeaponPM.AddEffect(e)

		Return True
	End

	'Add a GameObject to the temporary AddToSpace Stack
	Method AddObjectToSpace(o:GameObject)
		AddToSpace.Add(o)
		ObjectList.Add(o)
	End Method

	'Add a GameObject to the temporary RemoveFromSpace Stack
	Method RemoveObjectFromSpace(o:GameObject)
		RemoveFromSpace.Add(o)
	End Method

	'This method will be run at the end of our update routine when it's safe to add and remove GameObjects to/from the Chipmunk Space
	Method UpdateSpace()
		'loop through each stack and Add the body and shape of each object in the stack to the Space
		For Local o:=Eachin AddToSpace
			Space.AddBody( o.Body )
			Space.AddShape( o.Shape )
		Next
		'loop through each stack and Remove the body and shape of each object in the stack from the Space
		For Local o:=Eachin RemoveFromSpace
			Space.RemoveBody( o.Body )
			Space.RemoveShape( o.Shape )
			ObjectList.Remove( o )
		Next
		'Clear the stacks so they're empty and ready for the next update
		AddToSpace.Clear()
		RemoveFromSpace.Clear()
	End

	Method OnRender( canvas:Canvas ) Override
		CurrentCanvas = canvas

		'Call our OnUpdate method before any rendering. Note that we're not using and kind of timing code and just relying
		'on the Monitor refresh rate. This can be enhanced at some point.
		OnUpdate()

		'Request a render form the app
		App.RequestRender()

		'Clear the canvas with a color, in this case black
		canvas.Clear(New Color(0,0,0,0))

		'This changes the texture filter that the canvas uses. Linear is more crisper and looks nicer (in my opinion)
		canvas.TextureFiltering = False

		'This is the process to sort out the virtual resolution, start by pushing the canvas matrix onto the internal matrix stack
		canvas.PushMatrix()

		ScreenScale = New Vec2f(Width / VirtualResolution.x, Height / VirtualResolution.y)

		'Scale the canvas so that the virtual resolution will always fit in the screen.
		canvas.Scale(ScreenScale.x, ScreenScale.y)

		'Draw the background before anything else
		Background.Draw(canvas, Origin)

		'Call our render space method which will render all of our game objects.
		RenderSpace()

		'Render the particles
		WeaponPM.DrawParticles(canvas)

		'We've finished with the canvas matrix so pop it off the internal matrix stack
		canvas.PopMatrix()

		'Test the grid coordinates of the tilemap are working ok by converting the mouse coords
		'into tile map node coordinates. Divide the mouse coordinates by the screen scale to take into account
		'the virtual resolution and whether or not the window has been resized
		Local x:=Map.GetScreenNodeX(Mouse.X / ScreenScale.x, Origin)
		Local y:=Map.GetScreenNodeY(Mouse.Y / ScreenScale.y, Origin)

		'Then draw an oval by converting the node coordinates into world coordinates.
		'the center of the screen should be the centre of the tilemap - about 16,16
		canvas.DrawOval((Map.NodeXToWorld(x) - Origin.x) * ScreenScale.x, (Map.NodeYToWorld(y) - Origin.y) * ScreenScale.y, 5, 5)

		'Add a map tile to the map when the spacebar is pressed
		If Keyboard.KeyDown(Key.Space)
			Map.Paint(x, y, 0)
		End If

		'Erase a tile when backspace is pressed
		If Keyboard.KeyDown(Key.Backspace)
			Map.Erase(x, y, 0)
		End If

		'Reset the color for the text to white
		canvas.Color = New Color(1,1,1,1)
		'Draw the node coordinates for reference.
		canvas.DrawText(x + ", " + y, 10, 30)

		'Draw any useful info text for debugging here, after the popmatrix, so that it won't be scaled.
		canvas.DrawText("FPS: " + App.FPS, 10, 10)
	End

	'This method will convert screen coordinates into world coordinates (for example the mouse coordinates)
	'It will also take into account the current virtual resolution
	Method ScreenToWorld:Vec2f(screen:Vec2f)
		'Note: /= is a shortcut way of saying screen = screen / New Vec2f...
		screen/=New Vec2f(Width / VirtualResolution.x, Height / VirtualResolution.y)
		Return screen + Origin
	End

	'This is the update method that's called by the UpdateTimer
	Method OnUpdate()

		'Update the Space specifying what the current update rate is. Currently it needs to be the same as the monitor
		'refresh rate.
		Const timeStep:=1.0/60.0
		Space.StepTime( timeStep )

		'Create a shape filter which we will use to determine which objects in the space will be updated. We only need to
		'update the rocks and the player, the maptiles will be static objects and therefore will not need to be updated.
		Local spacefilter:=cpShapeFilterNew( ULong(0), Players|Rocks,  Players|Rocks)

		'This is how we query the chipmunk space with an area. We only want to update anything on the screen (you
		'can expand if you needed objects outside the screen to also be updated) so we use the
		'width and height of the window by the current origin so we get the space surrounding the player.
		'To define the Bounding Box (the area that is used to query the space)
		'we use a chipmunk function called cpBBNew. We also need to tell the query which function to call for each
		'object that it finds in the area which in this case is "UpdateSpaceCallBack". Finally we pass a pointer to the Me
		'field in this class so that we can access the CurrentCanvas for drawing to.
		cpSpaceBBQuery(Space, cpBBNew(Origin.x, Origin.y, Origin.x + VirtualResolution.x, Origin.y + VirtualResolution.y), spacefilter, UpdateSpaceCallBack, Varptr Me)

		'Set the origin to the player coordinates so that we can scroll around the map
		Origin = New Vec2f(Player.XY.x - Center.x, Player.XY.y - Center.y)

		'Update the particle managers
		WeaponPM.Update()
		'Match the origin of the particle manager to the game origin so that they're drawn in the right space
		WeaponPM.SetOrigin(Origin.x + Center.x, Origin.y + Center.y)

		'Perform our space maintainence by calling UpdateSpace which will add and remove objects to/from the space.
		UpdateSpace()
		'And update the Map as well to add/remove map tiles from the space
		Map.Update()
	End

	Method RenderSpace()
		'Create a shape filter which we will use to determine which objects in the space will be drawn (so far we only have Players)
		Local spacefilter:=cpShapeFilterNew( ULong(0), Players|MapTiles|Rocks,  Players|MapTiles|Rocks)

		'This is how we query the chipmunk space with an area. We only want to render the screen so we use the
		'width and height of the window by the current origin so we get the space surrounding the player.
		'To define the Bounding Box (the area that is used to query the space)
		'we use a chipmunk function called cpBBNew. We also need to tell the query which function to call for each
		'object that it finds in the area which in this case is "DrawSpaceCallBack". Finally we pass a pointer to the Me
		'field in this class so that we can access the CurrentCanvas for drawing to.
		cpSpaceBBQuery(Space, cpBBNew(Origin.x, Origin.y, Origin.x + VirtualResolution.x, Origin.y + VirtualResolution.y), spacefilter, DrawSpaceCallBack, Varptr Me)
	End

	'The draw space callback function. This is called everytime cpSpaceBBQuery (see above) finds an object in the area.
	'It allows us to draw each object that's found. 2 parameters are passed into the funtion, shape and data. Shape is
	'the shape that was found, and data is what we decided to pass though to the function, in this case it's the current
	'SpaceCraft instance so we can have access to the current canvas and various other things.
	Function DrawSpaceCallBack(shape:cpShape, data:Void Ptr)
		'The next 2 lines look a little confusing but it's quite straightforward. Firstly, the UserData field contained
		'in the shape contains a pointer to our GameObject which we want to draw, so we can "Cast" it to a GameObject. We need to do
		'this because on its own the UserData field is just a pointer to a variable, so we need to tell Wonkey what type
		'of object is at the end of that memory address. So we tell it its a GameObject Ptr with the below line. All the [0]
		'means is that we want to cast the first address in the array of date which is the starting point of the GameObject
		Local gobj:=Cast<GameObject Ptr>(shape.UserData)[0]
		'Then we do the same by casting data parameter to a SpaceCraft object (our Window)
		Local thegame:=Cast<SpaceCraft Ptr>(data)[0]
		'If we successfully cast the GameObject ok then render it to the sreen.
		If gobj And thegame
			gobj.Draw(thegame.CurrentCanvas, thegame.Origin)
		End
	End

	'The update space callback function. The same deal with the DrawSpaceCallBack above, it will be called each time an object
	'is found in the space to update.
	Function UpdateSpaceCallBack:Void(shape:cpShape, data:Void Ptr)
		'See comments above about casting the pointers into a GameObject.
		Local gobj:=Cast<GameObject Ptr>(shape.UserData)[0]
		If gobj
			'Update the GameObject
			gobj.Update()
		End If
	End

End

'Every Wonkey program needs a main function which executes the code we have written
Function Main()
	'Create a new App
	New AppInstance

	'Create a new Space craft game
	New SpaceCraft

	'Run the game!
	App.Run()
End

'Handy functions-----

'Sometime you need to be able to locate a specific point on an object, for example the nose of the player ship. This
'is simple until the player rotates and you need to calculate that position based on the rotation of the player.
'To do this we use a "Matrix", thankfully Wonkey makes that easy - just create a matrix, use the Rotate method of
'the matrix to rotate it by the amount needed and then multiply the coordinates of the position you want by the matrix.
'You'll get back a transformed vector that's now rotated into the correct position.
Function GetRotatedPoint:Vec2f(rz:Double, vec:Vec2f)
	Local matrix:=New AffineMat3f
	matrix = matrix.Rotate(rz)
	return matrix * vec
End
