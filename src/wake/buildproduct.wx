
Namespace wx

Class BuildProduct

	Field module:Module
	Field opts:BuildOpts
	Field imports:=New Stack<Module>
	Field outputFile:String
	
	Field CC_OPTS:String
	Field CPP_OPTS:String
	Field AS_OPTS:String
	Field LD_OPTS:String
	
	Field SRC_FILES:=New StringStack	'source code files
	Field JAVA_FILES:=New StringStack	'java files
	Field OBJ_FILES:=New StringStack	'object code files - added to module .a
	Field LIB_FILES:=New StringStack	'library files - passed to linker.
	Field DLL_FILES:=New StringStack	'dll/exe files, copied to app dir.
	
	Field ASSET_FILES:=New StringStack
	
	Field reflects:=New StringStack
	
	Method New( module:Module,opts:BuildOpts )
		
		Self.module=module
		Self.opts=opts
		
		Local copts:=""
		For Local moddir:=Eachin Module.Dirs
			copts+=" -I~q"+moddir+"~q"
		Next
		copts+=" -I~q"+Module.Dirs[0]+"wonkey/native~q"
		
		If APP_DIR copts+=" -I~q"+APP_DIR+"~q"

		CC_OPTS+=copts
		CPP_OPTS+=copts
	End

	Method Build()
		
'		If opts.verbose=0 
		Print "Compiling..."
		
		If Not CreateDir( module.cacheDir ) Throw New BuildEx( "Error creating dir '"+module.cacheDir+"'" )
			
		Local srcs:=New StringStack
		
		If opts.config="release" 
			CC_OPTS+=" -DNDEBUG=1"
			CPP_OPTS+=" -DNDEBUG=1"
		Endif

		If opts.threads
			CC_OPTS+=" -DWX_THREADS=1"
			CPP_OPTS+=" -DWX_THREADS=1"
		Endif
		
		If opts.productType="app"

			CC_OPTS+=" -I~q"+module.cacheDir+"~q"
			CPP_OPTS+=" -I~q"+module.cacheDir+"~q"
			
			reflects.Sort()
			
			Local buf:=New StringStack
			buf.Add( "//REFLECT" )

			For Local ref:=Eachin reflects
				ref="#define WX_R_"+ref.Replace( "_","_0" ).Replace( ".","_" )+" 1"
				buf.Add( ref )
			End
			
			Local rhead:=buf.Join( "~n" )
			
			CSaveString( rhead,module.cacheDir+"_r.h" )
			
			srcs.Push( module.rfile )
			
			For Local imp:=Eachin imports
			
				srcs.Push( imp.rfile )
			Next
		Endif
		
		For Local fdecl:=Eachin module.fileDecls
		
			srcs.Push( fdecl.cfile )
		Next
		
		srcs.AddAll( SRC_FILES )

		CheckModules()
		
		Build( srcs )
	End
	
	Method Build( srcs:StringStack ) Virtual
	End
	
	Method Run() Virtual
	End

	Protected
	
	Method AllocTmpFile:String( kind:String )
	
		CreateDir( "tmp" )

		For Local i:=1 Until 10
			Local file:="tmp/"+kind+i+".txt"
			DeleteFile( file )
			If GetFileType( file )=FileType.None Return file
		Next
		
		Throw New BuildEx( "Can't allocate tmp file" )
		
		Return ""
	End
	
	Method Exec:Bool( cmd:String,eatstdout:Bool=False )
		
		If opts.verbose=3 Print cmd
			
		Local fstdout:=eatstdout ? AllocTmpFile( "stdout" ) Else ""
		
		If eatstdout cmd+=" >"+fstdout
			
		Local fstderr:=AllocTmpFile( "stderr" )
		
		If Not system( cmd+" 2>"+fstderr ) Return True
		
		Local err:="System command failed:~n~n"+cmd+"~n~nerrors:~n~n"
		
		If eatstdout err+=LoadString( fstdout )+"~n"
		
		err+=LoadString( fstderr )
		
		Throw New BuildEx( err )
		
		Return False
	End
	
	Method CopyAssets( assetsDir:String )
	
		If Not assetsDir.EndsWith( "/" ) assetsDir+="/"
		
		Local assetFiles:=New StringMap<String>
		
		For Local src:=Eachin ASSET_FILES
		
			Local dst:=assetsDir
		
			Local i:=src.Find( "@/" )
			If i<>-1
				dst+=src.Slice( i+2 )
				src=src.Slice( 0,i )
				If Not dst.EndsWith( "/" ) dst+="/"
			Endif
			
			Select GetFileType( src )
			
			Case FileType.File
			
				dst+=StripDir( src )
				EnumAssetFiles( src,dst,assetFiles )
				
			Case FileType.Directory
			
				EnumAssetFiles( src,dst,assetFiles )
			End
			
		Next
		
		If assetFiles.Empty Return
		
		DeleteDir( assetsDir,True )
		
		CreateDir( assetsDir )
		
		CopyAssetFiles( assetFiles )
	End

	Method CopyDlls( dllsDir:String )
	
		If Not dllsDir.EndsWith( "/" ) dllsDir+="/"
	
		For Local src:=Eachin DLL_FILES
		
			Local dir:=dllsDir
			
			Local ext:=ExtractExt( src )
			If ext
				Local rdir:=GetEnv( "WX_APP_DIR_"+ext.Slice( 1 ).ToUpper() )
				If rdir
					dir=RealPath( dir+rdir )
					If Not dir.EndsWith( "/" ) dir+="/"
				Endif
			Endif
			
			Local dst:=dir+StripDir( src )
			
			'FIXME! Hack for copying frameworks on macos!
			'		
#If __HOSTOS__="macos"
			If ExtractExt( src ).ToLower()=".framework"
				CreateDir( ExtractDir( dst ) )
				If Not Exec( "rm -f -R "+dst ) Throw New BuildEx( "rm failed" )
				If Not Exec( "cp -f -R "+src+" "+dst ) Throw New BuildEx( "cp failed" )
				Continue
			Endif
#Endif
			
			If Not CopyAll( src,dst ) Throw New BuildEx( "Failed to copy '"+src+"' to '"+dst+"'" )
			
		Next
	
	End
		
	Private
		
	Method CopyAll:Bool( src:String,dst:String )
		
		Select GetFileType( src )

		Case FILETYPE_FILE
		
			If Not CreateDir( ExtractDir( dst ) ) Return False
		
'			If GetFileTime( src )>GetFileTime( dst )
				If Not CopyFile( src,dst ) Return False
'			Endif
			
			Return True
			
		Case FILETYPE_DIR
		
			If Not CreateDir( dst ) Return False
			
			For Local file:=Eachin LoadDir( src )
				If Not CopyAll( src+"/"+file,dst+"/"+file ) Return False
			Next
			
			Return True
		
		End
		
		Return False
		
	End
	
	Method CopyAssetFiles( files:StringMap<String> )
	
		For Local it:=Eachin files
		
			Local src:=it.Value
			Local dst:=it.Key
			
			If CreateDir( ExtractDir( dst ) )
			
				'If GetFileTime( dst )>=GetFileTime( src ) Continue
				
				If CopyFile( src,dst ) Continue

			Endif
			
			Throw New BuildEx( "Error copying asset file '"+src+"' to '"+dst+"'" )
		Next
	End
	
	Method EnumAssetFiles( src:String,dst:String,files:StringMap<String> )

		Select GetFileType( src )

		Case FILETYPE_FILE
		
			If Not files.Contains( dst ) files[dst]=src
			
		Case FILETYPE_DIR
		
			For Local f:=Eachin LoadDir( src )
			
				EnumAssetFiles( src+"/"+f,dst+"/"+f,files )

			Next
		
		End
		
	End

	Method CheckModules()
		'
		' Disable check for Android because imp.afile is not correct
		'
		If opts.target="android" Then Return

		'
		' Check that required modules are available when building app or module
		'    - the binary library: imp.afile
		'    - the source header:  imp.rfile
		'
		If opts.productType="app" Or opts.productType="module"
			Local missingModules:String

			For Local imp := Eachin imports
				Local afile := imp.afile

				If opts.toolchain="msvc"
					afile=StripExt(afile)+".lib"
				Elseif opts.target="emscripten" And Int(GetEnv("WX_USE_EMSC_VERSION"))<>2
					afile=StripExt(afile)+".bc"
				Endif

				If Not GetFileType( afile ) = FileType.File Or Not GetFileType( imp.rfile ) = FileType.File
					If missingModules Then missingModules += ", "
					missingModules += imp.name
			 	Endif
			Next

			If missingModules
				Local m:String = missingModules.Find(",") > 0 ? "modules" Else "module"

				Throw New BuildEx( "~n- Missing "+m+" for target="+opts.target+", config="+opts.config+": '"+
				                   missingModules+"'.~n- Please rebuild required "+m+
				                   " using: wake mods -clean -target="+opts.target+" -config="+opts.config+" "+missingModules.Replace(",","") )
			Endif
		Endif
	End
End

Class GccBuildProduct Extends BuildProduct
	
	Field CC_CMD:=""
	Field CXX_CMD:=""
	Field AS_CMD:=""
	Field AR_CMD:=""
	Field LD_CMD:=""
	
	Method New( module:Module,opts:BuildOpts )
		
		Super.New( module,opts )
		
		Local target:="_"+opts.target.ToUpper()
		Local config:="_"+opts.config.ToUpper()
		
		Select opts.toolchain
		Case "msvc"
			CC_CMD= "cl -c"
			CXX_CMD="cl -c"
			AS_CMD=opts.arch="x64" ? "ml64 -c" Else "ml -c"
			AR_CMD="lib"
			LD_CMD="link"
			target="_MSVC"
		Case "gcc"
			Select opts.target
			Case "emscripten"
				CC_CMD= "emcc -c"
				CXX_CMD="em++ -c"
				LD_CMD="em++"
				
				If Int(GetEnv("WX_USE_EMSC_VERSION"))=2
					AR_CMD="emar rcs"
				Else
					AR_CMD="em++ -o"
				End
				
			Case "raspbian"
				local prefix:=GetEnv("WX_GCC_EXEC_PREFIX")
				CC_CMD= prefix+"gcc -c"
				CXX_CMD=prefix+"g++ -c"
				LD_CMD= prefix+"g++"
				AR_CMD= prefix+"ar q"
				AS_CMD= prefix+"as"
			Case "ios"
				CC_CMD= "gcc -c"
				CXX_CMD="g++ -c"
				LD_CMD= "g++"
				AR_CMD= "libtool -o"
				AS_CMD= "as"
			Default
				CC_CMD= "gcc -c"
				CXX_CMD="g++ -c"
				LD_CMD= "g++"
				AR_CMD= "ar q"
				AS_CMD= "as"
			End
		Default
			RuntimeError( "Unrecognized error: '"+opts.toolchain+"'" )
		End
		
		CC_CMD+=" "+GetEnv( "WX_CC_OPTS"+target )+" "+GetEnv( "WX_CC_OPTS"+target+config )
		CXX_CMD+=" "+GetEnv( "WX_CPP_OPTS"+target )+" "+GetEnv( "WX_CPP_OPTS"+target+config )
		AS_CMD+=" "+GetEnv( "WX_AS_OPTS"+target )+" "+GetEnv( "WX_AS_OPTS"+target+config )
		AR_CMD+=" "+GetEnv( "WX_AR_OPTS"+target )+" "+GetEnv( "WX_AR_OPTS"+target+config )
		LD_CMD+=" "+GetEnv( "WX_LD_OPTS"+target )+" "+GetEnv( "WX_LD_OPTS"+target+config )
	End
	
	Method CompileSource:String( src:String )
		
		Local ext:=ExtractExt( src ).ToLower(),cmd:="",isasm:=False

		Select ext
		Case ".c",".m"
			
			cmd=CC_CMD+CC_OPTS
			
		Case ".cc",".cxx",".cpp",".mm"
			
			cmd=CXX_CMD+CPP_OPTS
			
		Case ".asm",".s"
			
			cmd=AS_CMD+AS_OPTS
			
			If opts.toolchain="msvc"
				
				If opts.arch="x64" 
					src=src.Replace( "_i386_","_x86_64_" )
				Endif
					
				src=src.Replace( "_pe_gas.","_pe_masm." )
				
			Else If opts.target="ios"
				
				If src.Contains( "_arm64_" )
					cmd+=" "+GetEnv( "WX_AS_OPTS_IOS_ARM64" )
				Else
					cmd+=" "+GetEnv( "WX_AS_OPTS_IOS_ARMV7" )
				Endif
				
			Endif
			
			isasm=True
		End
		
		Local obj:=module.cacheDir+HashPath( MakeRelativePath( src,module.cfileDir ) )

		If src.EndsWith( "/_r.cpp" ) obj+="_r"
			
		obj+=opts.toolchain="msvc" ? ".obj" Else ".o"
	
		'Check dependancies
		'			
		Local objTime:=GetFileTime( obj )

		'create deps file name
		'			
		Local deps:=StripExt( obj )+".deps"
		
		If opts.fast And objTime>=GetFileTime( src )	'source file up to date?
		
			If isasm Return obj
			
			If GetFileType( deps )=FileType.File
				
				Local uptodate:=True
				
				Local srcs:=LoadString( deps )
				If Not srcs Return obj
				
				For Local src:=Eachin srcs.Split( "~n" )
					
					Local time:=GetFileTime( src )
					
					If Not time Or time>objTime
						If Not time DeleteFile( deps )
						uptodate=False
						Exit
					Endif
				Next
				
				If uptodate Return obj
				
			Endif
		Else
			DeleteFile( deps )
		Endif
			
		If opts.verbose=1 Print StripDir( src )
			
		If opts.toolchain<>"msvc"
			
			If isasm
				cmd+=" -o ~q"+obj+"~q ~q"+src+"~q"
				Exec( cmd )
				Return obj
			Endif
			
			'A bit dodgy - rip out -arch's from ios
			#rem
			If opts.target="ios"
				Repeat
					Local i0:=cmd.Find( " -arch "  )
					If i0=-1 Exit
					Local i1:=cmd.Find( " ",i0+7 )
					If i1=-1 Exit
					cmd=cmd.Slice( 0,i0+1 )+cmd.Slice( i1+1 )
				Forever
				If opts.arch<>"x64" cmd+=" -arch armv7"
			Endif
			#end
			
			cmd+=" -MMD -MF~q"+deps+"~q"
			cmd+=" -o ~q"+obj+"~q ~q"+src+"~q"
			
			Exec( cmd )
			
			Local buf:=New StringStack
			Local lines:=LoadString( deps ).Split( " \" )
			For Local i:=1 Until lines.Length
				Local line:=lines[i].Trim().Replace( "\ "," " )
				If Not line Or line=src Continue
				buf.Add( line )
			Next
			SaveString( buf.Join( "~n" ),deps )
			
			Return obj
				
		Else If opts.toolchain="msvc"

			If isasm
				cmd+=" -Fo~q"+obj+"~q ~q"+src+"~q"
				Exec( cmd,opts.toolchain="msvc" )
				Return obj
			Endif
			
			Local fstdout:=AllocTmpFile( "stdout" )
			cmd+=" -showIncludes -Fo~q"+obj+"~q ~q"+src+"~q >"+fstdout
			
			Local fstderr:=AllocTmpFile( "stderr" )
			If system( cmd+" 2>"+fstderr )
				Local buf:=New StringStack
				For Local line:=Eachin LoadString( fstdout,True ).Split( "~n" )
					If Not line.StartsWith( "Note: including file:" ) buf.Add( line )
				Next
				Local err:="System command failed:~n~n"+cmd+"~n~n"+buf.Join( "~n" )+"~n"
				err+=LoadString( fstderr,True )
				Throw New BuildEx( err )
			Endif
			
			Local buf:=New StringStack
			Local lines:=LoadString( fstdout ).Split( "~n" )
			For Local line:=Eachin lines
				If Not line.StartsWith( "Note: including file:" ) Continue
				line=line.Slice( 21 ).Trim()
				If line.ToLower().Contains( "\program files (x86)\" ) Continue
				line=line.Replace( "\","/" )
				buf.Add( line )
			Next
			SaveString( buf.Join( "~n" ),deps )
			
			Return obj
		Endif

		cmd+=" -o ~q"+obj+"~q ~q"+src+"~q"
		Exec( cmd )
		Return obj
	End
	
	Method Build( srcs:StringStack ) Override
		
		Local objs:=New StringStack
		
		Local done:=New StringMap<Bool>
		
		For Local src:=Eachin srcs
			
			Local obj:=CompileSource( src )
			
			If done.Contains( obj )
				Print "OOPS! HASH COLLISION! CONTACT TEAM!"
				libc.exit_( -1 )
			Endif
			
			done[obj]=True
			
			objs.Push( obj )
		Next
		
		objs.AddAll( OBJ_FILES )
		
		If opts.productType="module"
			BuildModule( objs )
		Else
			BuildApp( objs )
		End
	End
	
	Method BuildModule( objs:StringStack )
		
		Local output:=module.afile
		
		If opts.toolchain="msvc" 
			output=StripExt( output )+".lib"
		Else If opts.target="emscripten" And Int(GetEnv("WX_USE_EMSC_VERSION"))<>2
			output=StripExt( output )+".bc"
		Endif
		
		Local maxObjTime:Long
		For Local obj:=Eachin objs
			maxObjTime=Max( maxObjTime,GetFileTime( obj ) )
		Next
		If GetFileTime( output )>maxObjTime Return
		
		If opts.verbose>=0 Print "Archiving "+output+"..."
		
		DeleteFile( output )
		
		Local cmd:="",args:=""
		For Local i:=0 Until objs.Length
			args+=" ~q"+objs.Get( i )+"~q"
		Next
		
		cmd=AR_CMD
#If __TARGET__="windows"
		Local tmp:=AllocTmpFile( "libFiles" )
		SaveString( args,tmp )
		
		If opts.toolchain="msvc"
			cmd+=" -out:~q"+output+"~q @~q"+tmp+"~q"
		Else
			cmd+=" ~q"+output+"~q @~q"+tmp+"~q"
		Endif
#Else
		cmd+=" ~q"+output+"~q"+args
#Endif
		
		Exec( cmd,opts.toolchain="msvc" )
	End
	
	Method BuildApp( objs:StringStack ) Virtual
		
		outputFile=opts.product
		If Not outputFile outputFile=module.outputDir+module.name
		
		Local productDir:=ExtractDir( outputFile )
		
		Local assetsDir:=productDir+"assets/"
		
		Local dllsDir:=productDir

		Local cmd:=LD_CMD+LD_OPTS
		
		Local plistFile:String, macApp:String
				
		Select opts.target
		Case "windows"
		
			If ExtractExt( outputFile ).ToLower()<>".exe" outputFile+=".exe"
				
			If opts.toolchain="msvc"
'				cmd+=" -entry:main"
				If opts.appType="gui" cmd+=" -subsystem:windows" Else cmd+=" -subsystem:console"
			Else
				If opts.appType="gui" cmd+=" -mwindows"
			Endif
			
		Case "macos"
		
			If opts.appType="gui"
			
				Local appDir:=outputFile
				If ExtractExt( appDir ).ToLower()<>".app" appDir+=".app"

				macApp = appDir
				appDir += "/"
				plistFile = appDir+"Contents/Info.plist"
				
				Local appName:=StripExt( StripDir( outputFile ) )
				
				outputFile=appDir+"Contents/MacOS/"+appName
				assetsDir=appDir+"Contents/Resources/"
				dllsDir=ExtractDir( outputFile )
				
				If GetFileType( appDir )=FileType.None

					CreateDir( appDir )
					CreateDir( appDir+"Contents" )
					CreateDir( appDir+"Contents/MacOS" )
					CreateDir( appDir+"Contents/Resources" )
					
					Local plist:=""
					plist+="<?xml version=~q1.0~q encoding=~qUTF-8~q?>~n"
					plist+="<!DOCTYPE plist PUBLIC ~q-//Apple Computer//DTD PLIST 1.0//EN~q ~qhttp://www.apple.com/DTDs/PropertyList-1.0.dtd~q>~n"
					plist+="<plist version=~q1.0~q>~n"
					plist+="<dict>~n"
					plist+="~t<key>CFBundleExecutable</key>~n"
					plist+="~t<string>"+appName+"</string>~n"
					plist+="~t<key>CFBundleIconFile</key>~n"
					plist+="~t<string>"+appName+"</string>~n"
					plist+="~t<key>CFBundlePackageType</key>~n"
					plist+="~t<string>APPL</string>~n"
					plist+="~t<key>NSHighResolutionCapable</key> <true/>~n"
					plist+="</dict>~n"
					plist+="</plist>~n"
					
					SaveString( plist,plistFile )
				
				Endif
			
			Endif
		
		Case "emscripten"

			assetsDir=module.outputDir+"assets/"
			
			If ExtractExt( outputFile ).ToLower()<>".js" And ExtractExt( outputFile ).ToLower()<>".html" outputFile+=".html"
			
			cmd+=" --preload-file ~q"+assetsDir+"@/assets~q"
			
'			If opts.appType.StartsWith( "wasm" ) cmd+=" -s BINARYEN=1 -s BINARYEN_TRAP_MODE='allow'"

			If opts.appType.StartsWith( "wasm" )
				Local wopts:=GetEnv( "WX_LD_OPTS_EMSCRIPTEN_WASM" )
				If Not wopts wopts="-s BINARYEN=1 -s BINARYEN_TRAP_MODE='allow'"
				cmd+=" "+wopts
			Endif
		End
		
		If opts.verbose>=0 Print "Linking "+outputFile+"..."
			
		If opts.toolchain="msvc"
			cmd+=" -entry:mainCRTStartup -out:~q"+outputFile+"~q"
		Else
			cmd+=" -o ~q"+outputFile+"~q"
		Endif
		
		Local lnkFiles:=""
		
		For Local obj:=Eachin objs
			lnkFiles+=" ~q"+obj+"~q"
		Next
		
		For Local imp:=Eachin imports
			Local afile:=imp.afile
			If opts.target="emscripten" And Int(GetEnv("WX_USE_EMSC_VERSION"))<>2
				afile=StripExt(afile)+".bc"
			Else If opts.toolchain="msvc" 
				afile=StripExt(afile)+".lib"
			Endif
			lnkFiles+=" ~q"+afile+"~q"
		Next

		lnkFiles+=" "+LIB_FILES.Join( " " )

#If __TARGET__="windows"
		Local icon_resource_output:String
		If opts.target="windows" And opts.appIcon
			'
			' create icon resources on windows
			'
			Local appIconDestination:String = AllocTmpFile( StripDir(outputFile)+"_exeIcon_resource_" ).Replace(".txt","")
			Local appIconName:String = "."+StripDir(opts.appIcon)
			If Not CopyFile( opts.appIcon,appIconDestination+appIconName )
				Print "Could not copy Icon resource."
				Print "    Icon: "+opts.appIcon
				Print "    Destination: "+appIconDestination+appIconName
			Else
				SaveString("AppIcon ICON ~q"+appIconDestination+appIconName+"~q~n",appIconDestination+appIconName+".rc")
				icon_resource_output = appIconDestination+appIconName
				If opts.toolchain="gcc"
					icon_resource_output += ".o"
					If Not system("windres ~q"+appIconDestination+appIconName+".rc~q ~q"+icon_resource_output+"~q > ~q"+appIconDestination+".err~q")
						lnkFiles += " ~q"+appIconDestination+appIconName+".o~q"
					Else
						Print "Could not create icon resource using gcc's windres."
					Endif
				Elseif opts.toolchain="msvc"
					icon_resource_output += ".res"
					Local rc := GetEnv("WX_MSVC_RC_"+opts.arch)
					If rc Then rc += "\"
					If Not system("~q"+rc+"rc.exe~q /nologo /r /fo ~q"+icon_resource_output+"~q ~q"+appIconDestination+appIconName+".rc~q > ~q"+appIconDestination+".err~q")
						lnkFiles += " ~q"+appIconDestination+appIconName+".res~q"
					Else
						Print "Could not create icon resource using MSVC RC.exe."
						If GetFileType(rc+"rc.exe") = FileType.None
							Print "    not found: ~q"+rc+"rc.exe~q"
							Print "    please check your environment variable 'WX_MSVC_RC_"+opts.arch+"'"
						Endif
					Endif
				Endif
				DeleteFile(appIconDestination+appIconName)
				DeleteFile(appIconDestination+appIconName+".rc")
				DeleteFile(appIconDestination+".err")
			Endif
		Endif


		lnkFiles=lnkFiles.Replace( " -Wl,"," " )
		Local tmp:=AllocTmpFile( "lnkFiles" )
		SaveString( lnkFiles,tmp )
		cmd+=" @"+tmp
#Else
		cmd+=lnkFiles
#Endif
		CreateDir( productDir,True )
		
		CopyAssets( assetsDir )
		
		CopyDlls( dllsDir )
		
		Exec( cmd,opts.toolchain="msvc" )
		
		If opts.target="emscripten"
			If opts.appType="wasm"
				DeleteFile( StripExt( outputFile )+".asm.js" )
			Endif
		Endif

#If __TARGET__="windows"
		If opts.target="windows" And opts.appIcon And icon_resource_output
			DeleteFile(icon_resource_output)
		Endif
#Endif

		If opts.target="macos" And opts.appType="gui" And opts.appIcon
			'
			' copy icon on macOS
			'
			Local appIconDestination:String = assetsDir+StripDir( outputFile )+".icns"
			If Not CopyFile( opts.appIcon,appIconDestination )
				Print "Could not copy Icon file."
				Print "    Icon: "+opts.appIcon
				Print "    Destination: "+appIconDestination
			Endif
			'
			' touch is required for updating the app icon
			'
			Exec("touch ~q"+plistFile+"~q")
			Exec("touch ~q"+macApp+"~q")
		Endif

	End
	
	Method Run() Override
	
		Local run:=""
		Select opts.target
		Case "emscripten"
			Local mserver:=GetEnv( "WX_MSERVER" )
			run=mserver+" ~q"+outputFile+"~q"
		Default
			run="~q"+outputFile+"~q"
		End
		
		If opts.verbose>=0 Print "Running "+outputFile
			
		Exec( run )
	End
	
End

Class IosBuildProduct Extends GccBuildProduct

	Method New( module:Module,opts:BuildOpts )
	
		Super.New( module,opts )
	End
	
	Method BuildApp( objs:StringStack ) Override
	
		BuildModule( objs )
		
		Local arc:=module.afile

		Local outputFile:=opts.product+"libwx_main.a"
		
		Local cmd:="libtool -static -o ~q"+outputFile+"~q ~q"+arc+"~q"
		
		If opts.wholeArchive cmd+=" -Wl,--whole-archive"
		
		For Local imp:=Eachin imports
			cmd+=" ~q"+imp.afile+"~q"
		Next

		If opts.wholeArchive cmd+=" -Wl,--no-whole-archive"
		
		For Local lib:=Eachin LIB_FILES
			If lib.ToLower().EndsWith( ".a~q" ) cmd+=" "+lib
		Next
		
		Exec( cmd )
		
		CopyAssets( opts.product+"assets/" )

		If opts.target="ios" And opts.appIcon
			'
			' copy icon on ios
			'
			Local appIconDestination:String = opts.product+"Icon.icns"
			If Not CopyFile( opts.appIcon,appIconDestination )
				Print "Could not copy Icon file."
				Print "    Icon: "+opts.appIcon
				Print "    Destination: "+appIconDestination
			Endif
			'
			' touch is required for updating the app icon
			'
			If GetFileType(opts.product+"Info.plist") = FileType.File
				Exec("touch ~q"+opts.product+"Info.plist~q",True)
			Endif
		Endif

	End
	
	Method Run() Override
	End
	
End

Function SplitOpts:String[]( opts:String )

	Local out:=New StringStack

	Local i0:=0
	Repeat
	
		While i0<opts.Length And opts[i0]<=32
			i0+=1
		Wend
		If i0>=opts.Length Exit

		Local i1:=opts.Find( " ",i0 )
		If i1=-1 i1=opts.Length

		Local i2:=opts.Find( "~q",i0 )
		If i2<>-1 And i2<i1
			i1=opts.Find( "~q",i2+1 )+1
			If Not i1 i1=opts.Length
		Endif

		out.Push( opts.Slice( i0,i1 ) )
		i0=i1+1
	
	Forever
	
	Return out.ToArray()
End

Class AndroidBuildProduct Extends BuildProduct

	Method New( module:Module,opts:BuildOpts )

		Super.New( module,opts )
	End
	
	Method Build( srcs:StringStack ) Override
	
		Local jniDir:=module.outputDir+"jni/"
		
		If Not CreateDir( jniDir ) Throw New BuildEx( "Failed to create dir '"+jniDir+"'" )
	
		Local buf:=New StringStack
		
		buf.Push( "APP_OPTIM := "+opts.config )
		
		buf.Push( "APP_ABI := "+GetEnv( "WX_ANDROID_APP_ABI","armeabi-v7a" ) )
		
		buf.Push( "APP_PLATFORM := "+GetEnv( "WX_ANDROID_APP_PLATFORM","android-14" ) )
		
		buf.Push( "APP_CFLAGS := "+GetEnv( "WX_ANDROID_APP_CFLAGS","-std=gnu99 -fno-stack-protector" ) )
		
		buf.Push( "APP_CPPFLAGS := "+GetEnv( "WX_ANDROID_APP_CPPFLAGS","-std=c++11 -fno-stack-protector -frtti -fexceptions" ) )
		
		buf.Push( "APP_STL := "+GetEnv( "WX_ANDROID_APP_STL","c++_static" ) )
		
		#rem
		buf.Push( "APP_CFLAGS += -std=gnu99" )
		buf.Push( "APP_CFLAGS += -fno-stack-protector" )
		
		buf.Push( "APP_CPPFLAGS += -std=c++11" )
		buf.Push( "APP_CPPFLAGS += -frtti" )
		buf.Push( "APP_CPPFLAGS += -fexceptions" )
		buf.Push( "APP_CPPFLAGS += -fno-stack-protector" )
		
		buf.Push( "APP_STL := c++_static" )
		
		#end
		
		CSaveString( buf.Join( "~n" ),jniDir+"Application.mk" )
		
		buf.Clear()

		buf.Push( "LOCAL_PATH := $(call my-dir)" )
		
		If opts.productType="app"
		
			For Local imp:=Eachin imports
			
				Local src:=imp.outputDir+"obj/local/$(TARGET_ARCH_ABI)/libwx_"+imp.name+".a"
					
				buf.Push( "include $(CLEAR_VARS)" )
				buf.Push( "LOCAL_MODULE := wx_"+imp.name )
				buf.Push( "LOCAL_SRC_FILES := "+src )
				buf.Push( "include $(PREBUILT_STATIC_LIBRARY)" )
			Next
			
			For Local dll:=Eachin DLL_FILES
			
				buf.Push( "include $(CLEAR_VARS)" )
				buf.Push( "LOCAL_MODULE := "+StripDir( dll ) )
				buf.Push( "LOCAL_SRC_FILES := "+dll )
				buf.Push( "include $(PREBUILT_SHARED_LIBRARY)" )
			
			Next
			
		Endif
		
		buf.Push( "include $(CLEAR_VARS)" )
		
		If opts.productType="app"
			buf.Push( "LOCAL_MODULE := wx_main" )
		Else
			buf.Push( "LOCAL_MODULE := wx_"+module.name )
		Endif
		
		Local cc_opts:=SplitOpts( CC_OPTS )
		
		For Local opt:=Eachin cc_opts
			If opt.StartsWith( "-I" ) Or opt.StartsWith( "-D" ) buf.Push( "LOCAL_CFLAGS += "+opt )
		Next
		
		' Add Anroid SDK path
		Local ndk := GetEnv( "WX_ANDROID_NDK" )
		If ndk
			If ndk.StartsWith("~q") And ndk.EndsWith("~q") Then ndk = ndk.Slice(1,-1)
			If Not ndk.EndsWith("/") Then ndk += "/"
			buf.Push( "LOCAL_CFLAGS += -I~q"+ndk+"~q" )
		Endif
		
		buf.Push( "LOCAL_SRC_FILES := \" )
		
		For Local src:=Eachin srcs
			buf.Push( MakeRelativePath( src,jniDir )+" \" )
'			buf.Push( MakeRelativePath( src,module.cfileDir )+" \" )
		Next
		
		buf.Push( "" )

		buf.Push( "LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES" )
		
		If opts.productType="app"
		
			Local whole_libs:=""
		
			buf.Push( "LOCAL_STATIC_LIBRARIES := \" )
			For Local imp:=Eachin imports
				If imp=module Continue
				
				If imp.name="sdl2" 'Or imp.name="admob" 'Or imp.name="std"
					whole_libs+=" wx_"+imp.name
					Continue
				Endif
				
				buf.Push( "wx_"+imp.name+" \" )
			Next
			buf.Push( "" )
			
			If whole_libs
				'
				'This keeps the JNI functions in sdl2 and admob alive: ugly, ugly stuff but that's the joys of modern coding for ya...
				'
				buf.Push( "LOCAL_WHOLE_STATIC_LIBRARIES :="+whole_libs )
			Endif

			buf.Push( "LOCAL_SHARED_LIBRARIES := \" )
			For Local dll:=Eachin DLL_FILES
				buf.Push( StripDir( dll )+" \" )
			Next
			buf.Push( "" )
			
			buf.Push( "LOCAL_LDLIBS += -ldl" )
			
			For Local lib:=Eachin LIB_FILES
				If lib.StartsWith( "-l" ) buf.Push( "LOCAL_LDLIBS += "+lib )
			Next
			
			buf.Push( "LOCAL_LDLIBS += -llog -landroid" )

			buf.Push( "include $(BUILD_SHARED_LIBRARY)" )
		Else

			buf.Push( "include $(BUILD_STATIC_LIBRARY)" )
		Endif
		
		CSaveString( buf.Join( "~n" ),jniDir+"Android.mk" )
		buf.Clear()
		
		Local cd:=CurrentDir()
		
		ChangeDir( module.outputDir )
		
		Exec( "ndk-build" )
		
		ChangeDir( cd )
		
		If opts.productType="app" And opts.product
		
			For Local jfile:=Eachin JAVA_FILES
			
				Local src:=LoadString( jfile )
				If Not src Continue
				
				Local i0:=src.Find( "package " )
				If i0=-1 Continue
				
				Local i1:=src.Find( ";",i0+8 )
				If i1=-1 Continue
				
				Local pkg:=src.Slice( i0+8,i1 ).Trim()
				If Not pkg Continue
				
				Local dstDir:=opts.product+"app/src/main/java/"+pkg.Replace( ".","/" )
				
				CreateDir( dstDir,True )
				
				CopyFile( jfile,dstDir+"/"+StripDir( jfile ) )
			Next
		
			CopyAssets( opts.product+"app/src/main/assets/" )
		
			CopyDir( module.outputDir+"libs",opts.product+"app/src/main/jniLibs" )
		
		Endif
		
	End
	
End
